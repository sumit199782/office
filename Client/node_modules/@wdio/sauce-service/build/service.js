"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _saucelabs = _interopRequireDefault(require("saucelabs"));

var _logger = _interopRequireDefault(require("@wdio/logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const jobDataProperties = ['name', 'tags', 'public', 'build', 'custom-data'];
const log = (0, _logger.default)('@wdio/sauce-service');

class SauceService {
  constructor() {
    this.testCnt = 0;
    this.failures = 0;
  }

  beforeSession(config, capabilities) {
    this.config = config;
    this.capabilities = capabilities;
    this.api = new _saucelabs.default(this.config);
    this.isRDC = 'testobject_api_key' in this.capabilities;
    this.isServiceEnabled = true;

    if (!this.isRDC && !config.user) {
      this.isServiceEnabled = false;
      config.user = 'unknown_user';
    }

    if (!this.isRDC && !config.key) {
      this.isServiceEnabled = false;
      config.key = 'unknown_key';
    }

    this.config.user = config.user;
    this.config.key = config.key;
    this.sauceUser = this.config.user;
    this.sauceKey = this.config.key;
  }

  beforeSuite(suite) {
    this.suiteTitle = suite.title;
  }

  beforeTest(test) {
    if (!this.isServiceEnabled || this.isRDC) {
      return;
    }

    if (this.suiteTitle === 'Jasmine__TopLevel__Suite') {
      this.suiteTitle = test.fullName.slice(0, test.fullName.indexOf(test.title) - 1);
    }

    global.browser.execute('sauce:context=' + test.fullTitle);
  }

  afterSuite(suite) {
    if (Object.prototype.hasOwnProperty.call(suite, 'error')) {
      ++this.failures;
    }
  }

  afterTest(test) {
    if (!test.passed) {
      ++this.failures;
    }
  }

  beforeFeature(uri, feature) {
    if (!this.isServiceEnabled || this.isRDC) {
      return;
    }

    this.suiteTitle = feature.document.feature.name;
    global.browser.execute('sauce:context=Feature: ' + this.suiteTitle);
  }

  beforeScenario(uri, feature, scenario) {
    if (!this.isServiceEnabled || this.isRDC) {
      return;
    }

    const scenarioName = scenario.name;
    global.browser.execute('sauce:context=Scenario: ' + scenarioName);
  }

  afterScenario(uri, feature, pickle, result) {
    if (result.status === 'failed') {
      ++this.failures;
    }
  }

  after(result) {
    if (!this.isServiceEnabled && !this.isRDC) {
      return;
    }

    let failures = this.failures;

    if (global.browser.config.mochaOpts && global.browser.config.mochaOpts.bail && Boolean(result)) {
      failures = 1;
    }

    const status = 'status: ' + (failures > 0 ? 'failing' : 'passing');

    if (!global.browser.isMultiremote) {
      log.info(`Update job with sessionId ${global.browser.sessionId}, ${status}`);
      return this.updateJob(global.browser.sessionId, failures);
    }

    return Promise.all(Object.keys(this.capabilities).map(browserName => {
      log.info(`Update multiremote job for browser "${browserName}" and sessionId ${global.browser[browserName].sessionId}, ${status}`);
      return this.updateJob(global.browser[browserName].sessionId, failures, false, browserName);
    }));
  }

  onReload(oldSessionId, newSessionId) {
    if (!this.isServiceEnabled && !this.isRDC) {
      return;
    }

    const status = 'status: ' + (this.failures > 0 ? 'failing' : 'passing');

    if (!global.browser.isMultiremote) {
      log.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${status}`);
      return this.updateJob(oldSessionId, this.failures, true);
    }

    const browserName = global.browser.instances.filter(browserName => global.browser[browserName].sessionId === newSessionId)[0];
    log.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${status}`);
    return this.updateJob(oldSessionId, this.failures, true, browserName);
  }

  async updateJob(sessionId, failures, calledOnReload = false, browserName) {
    if (this.isRDC) {
      await this.api.updateTest(sessionId, {
        passed: failures === 0
      });
      this.failures = 0;
      return;
    }

    const body = this.getBody(failures, calledOnReload, browserName);
    await this.api.updateJob(this.sauceUser, sessionId, body);
    this.failures = 0;
  }

  getBody(failures, calledOnReload = false, browserName) {
    let body = {};
    body.name = this.suiteTitle;

    if (browserName) {
      body.name = `${browserName}: ${body.name}`;
    }

    if (calledOnReload || this.testCnt) {
      let testCnt = ++this.testCnt;

      if (global.browser.isMultiremote) {
        testCnt = Math.ceil(testCnt / global.browser.instances.length);
      }

      body.name += ` (${testCnt})`;
    }

    for (let prop of jobDataProperties) {
      if (!this.capabilities[prop]) {
        continue;
      }

      body[prop] = this.capabilities[prop];
    }

    body.passed = failures === 0;
    return body;
  }

}

exports.default = SauceService;